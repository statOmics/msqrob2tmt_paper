
## Pre-process the spikein1 data set ##

## This script loads the UPS spike-in data by Huang et al. 2020 and
## performs data pre-processing. The output of the script is a
## QFeatures object that will be used by all methods benchmarked in
## this study.

####---- Setup environment ----####

library("msqrob2")
library("BiocFileCache")
library("dplyr")

dataDir <- "data/"

####---- Load data ----####

## Download data (if needed)
bfc <- BiocFileCache()
psmFile <- bfcrpath(bfc, "https://zenodo.org/records/14767905/files/spikein1_psms.txt?download=1")
annotFile <- bfcrpath(bfc, "https://zenodo.org/records/14767905/files/spikein1_annotations.csv?download=1")

## Read in the PSM data
psms <- read.delim(psmFile)
## Read in the sample annotations
coldata <- read.csv(annotFile)
coldata <- coldata[, c("Run", "Channel", "Condition", "Mixture", "TechRepMixture")]
coldata$FileName <- coldata$Run
coldata$Run <- sub("^.*(Mix.*).raw", "\\1", coldata$Run)
coldata$SampleId <- paste0(coldata$Run, "_", coldata$Channel)

## Format to QFeatures
coldata$runCol <- coldata$FileName
coldata$quantCols <- paste0("Abundance..", coldata$Channel)
spikein1 <- readQFeatures(psms, colData = coldata,
                         quantCols = unique(coldata$quantCols),
                         runCol = "Spectrum.File", name = "psms")
names(spikein1) <- sub("^.*(Mix.*).raw", "\\1", names(spikein1))
spikein1

####---- PSM filtering ----####

## These first filtering steps are specific to the UPS spike-in study,
## and account for the pecularities with respect to using 2
## identification nodes

## Remove failed protein inference
spikein1 <- filterFeatures(spikein1, ~ Protein.Accessions != "")

## Remove duplicated spectra
for (i in names(spikein1)) {
    x <- assay(spikein1[[i]])
    duplicatesQuants <- duplicated(x) | duplicated(x, fromLast = TRUE)
    rowData(spikein1[[i]])$duplicatesQuants <- as.vector(duplicatesQuants)
}
spikein1 <- filterFeatures(spikein1, ~ !duplicatesQuants)

## Remove protein groups
spikein1 <- filterFeatures(spikein1, ~ !grepl(";", Protein.Accessions))

## Add a unique ion identifier
rowdata <- rbindRowData(spikein1, names(spikein1))
rowdata$ionID <- paste0(
    rowdata$Annotated.Sequence, "_",
    rowdata$Modifications, "_",
    rowdata$Charge, "_",
    ifelse(grepl("ups",rowdata$Protein.Accessions), "_ups", "")
)
rowData(spikein1) <- split(rowdata, rowdata$assay)

## Remove ambiguous PSM
rowdata <- rbindRowData(spikein1, names(spikein1))
rowdata$isUps <- "no"
isUpsProtein <- grepl("ups", rowdata$Protein.Accessions)
rowdata$isUps[isUpsProtein] <- "yes"
rowdata$isUps[!isUpsProtein & grepl("UPS", rowdata$Marked.as)] <- "amb"
rowdata$isUps[isUpsProtein & !grepl("UPS", rowdata$Marked.as)] <- "amb"
rowData(spikein1) <- split(rowdata, rowdata$assay)
spikein1 <- filterFeatures(spikein1, ~ isUps != "amb")

####---- Save data for MSstatsTMT ----####

spikein1msstatstmt <- do.call(rbind, lapply(grep("\\d$", names(spikein1)), function(i) {
    se <- spikein1[[i]]
    m <- assay(se)
    colnames(m) <- sub(".*(Abun.*)", "\\1", colnames(m))
    data.frame(rowData(se), m)
}))
saveRDS(spikein1msstatstmt,
        paste0(dataDir, "spikein1_input_msstatstmt.rds"))

####---- Save data for msTrawler ----####

## It is not clear whether msTrawler can deal with replication, and
## there is no documentation available that illustrates it
spikein1msTrawler <- subsetByColData(spikein1, spikein1$TechRepMixture == 1)
spikein1msTrawler <- dropEmptyAssays(spikein1msTrawler)

## Convert back to a Skyline-like file because msTrawler is very
## sensitive to the column names in the input table.
## First, get Skyline's initial headers
skylineHeaders <- BiocFileCache() |>
    bfcrpath("https://zenodo.org/records/14767905/files/spikein1_psms.txt?download=1") |>
    read.delim(nrows = 1, header = FALSE, check.names = FALSE) |>
    unlist() |>
    unname()
## Then regenerate the Skyline table
spikein1msTrawler <- lapply(names(spikein1msTrawler), function(i) {
    m <- assay(spikein1msTrawler[[i]])
    colnames(m) <- sub(".*raw_", "", colnames(m))
    rd <- rowData(spikein1msTrawler[[i]])[, 1:40] ## Keeping only columns generated by Skyline
    ## Insert quant cols in annotations, respecting the order by Skyline
    skyline <- cbind(rd[, 1:33], m, rd[, 34:40])
    colnames(skyline) <- skylineHeaders
    data.frame(skyline, check.names = FALSE)
})
spikein1msTrawler <- do.call(rbind, spikein1msTrawler)

## Store file locally as a TXT file (expected by msTrawler)
write.table(
    spikein1msTrawler,
    file = paste0(dataDir, "spikein1_input_msTrawler.txt"),
    sep = "\t", row.names = FALSE,
    col.names = colnames(spikein1msTrawler)
)

####---- Further PSM filtering ----####

## These filtering steps are part of msqrob2TMT workflow, but will
## also be used for DEqMS

## Remove peptide ions that map to a different protein depending on
## the run
rowdata <- rbindRowData(spikein1, names(spikein1))
rowdata <- data.frame(rowdata) |>
    group_by(ionID) |>
    mutate(nProtsMapped = length(unique(Protein.Accessions)))
rowData(spikein1) <- split(rowdata, rowdata$assay)
spikein1 <- filterFeatures(spikein1, ~ nProtsMapped == 1)

## When a peptide ion is identified across multiple PSMs within a run
## keep only spectra with highest sum intensity
for (i in names(spikein1)) {
    rowdata <- rowData(spikein1[[i]])
    rowdata$psmSum <- rowSums(assay(spikein1[[i]]), na.rm = TRUE)
    rowdata <- data.frame(rowdata) |>
        group_by(ionID) |>
        mutate(psmRank = rank(-psmSum))
    rowData(spikein1[[i]]) <- rowdata
}
spikein1 <- filterFeatures(spikein1, ~ psmRank == 1)

## Rename the rows by the ion identifier
for (i in names(spikein1)) {
    rownames(spikein1[[i]]) <- rowData(spikein1[[i]])$ionID
}

####---- Missing data management ----####

## Replace 0s by NAs
spikein1 <- zeroIsNA(spikein1, names(spikein1))
## Remove PSMs with 5 or more missing values out of 10 TMT channels
## (>= 50%).
spikein1 <- filterNA(spikein1, names(spikein1), pNA = 0.5)

####---- Log transformation ----####

spikein1 <- logTransform(
    spikein1, names(spikein1), name = paste0(names(spikein1), "_log"),
    base = 2
)

####---- Save data for DEqMS ----####

## Remove technical replicates (cannot be modelled by DEqMS)
spikein1deqms <- subsetByColData(spikein1, spikein1$TechRepMixture == 1)
spikein1deqms <- dropEmptyAssays(spikein1deqms)
## Remove reference channel (not used by DEqMS)
spikein1deqms <- subsetByColData(spikein1deqms, spikein1deqms$Condition != "Norm")
## DEqMS requires log transformed data
logNames <- grep("log", names(spikein1deqms), value = TRUE)
## Convert QFeatures into a DEqMS-compatible data.frame
spikein1deqms <- lapply(logNames, function(i) {
    se <- spikein1deqms[[i]]
    out <- cbind(
        ## Feature annotations
        rowData(se)[, c("ionID", "Protein.Accessions")],
        ## Quantitative data
        assay(se)
    )
    data.frame(out, check.names = FALSE)
})
## Join all runs in a single table
spikein1deqms <- Reduce(
    function(x, y) full_join(x, y, by = join_by(ionID, Protein.Accessions)),
    spikein1deqms
)
saveRDS(spikein1deqms, "data/spikein1_input_deqms.rds")

####---- Save data for msqrob2TMT ----####

## Store the processed spikein1 data
saveRDS(spikein1, "data/spikein1_input_msqrob2tmt.rds")

